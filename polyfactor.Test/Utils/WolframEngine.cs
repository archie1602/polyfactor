using System;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Diagnostics;
using System.Collections;
using System.Text.Encodings.Web;
using System.Collections.Generic;

using Xunit;

using polyfactor.Test.Domain;
using polyfactor.Test.Utils;

using polyfactor.Test.Data.GFPols;
using polyfactor.Test.Data.GFPols.AddPols;
using polyfactor.Test.Data.GFPols.SubPols;
using polyfactor.Test.Data.GFPols.MulPols;
using polyfactor.Test.Data.GFPols.DivPols.Quotient;
using polyfactor.Test.Data.GFPols.DivPols.Remainder;
using polyfactor.Test.Data.GFPols.GCDPols;
using polyfactor.Test.Data.GFPols.ComparePols;
using polyfactor.Test.Data.GFPols.FactorPol;

using polyfactor.GaloisStructs;

namespace polyfactor.Test.Utils
{
    public class WolframEngine
    {
        private readonly string _pathToWolframScript = @"C:\Program Files\Wolfram Research\Mathematica\13.0\wolframscript.exe";

        //private readonly IKernelLink _ml;

        public WolframEngine()
        {
            //string[] mlArgs = { "-linkmode", "launch", "-linkname", @"C:\Program Files\Wolfram Research\Wolfram Engine\13.0\wolfram.exe" };

            //// This launches the Mathematica kernel:
            //_ml = MathLinkFactory.CreateKernelLink(mlArgs);

            //// Discard the initial InputNamePacket the kernel will send when launched.
            //_ml.WaitAndDiscardAnswer();
        }

        public string ExecuteCmd(string cmd)
        {
            var processInfo = new ProcessStartInfo(_pathToWolframScript);

            var engineCmd = "-code";

            processInfo.Arguments = string.Format("\"{0}\" \"{1}\"", engineCmd, cmd);
            processInfo.UseShellExecute = false;// Do not use OS shell
            processInfo.CreateNoWindow = true; // We don't need new window
            processInfo.RedirectStandardOutput = true;// Any output, generated by application will be redirected back
            processInfo.RedirectStandardError = true; // Any error in standard output will be redirected back (for example exceptions)

            using (var process = Process.Start(processInfo))
            {
                using (var reader = process.StandardOutput)
                {
                    string stderr = process.StandardError.ReadToEnd(); // Here are the exceptions from our wolfram script
                    string result = reader.ReadToEnd(); // Here is the result of StdOut(for example: print "test")

                    return result;
                }
            }
        }

        public void ExecuteFile(string pathToFile)
        {
            var processInfo = new ProcessStartInfo(_pathToWolframScript);

            var engineCmd = "-file";

            processInfo.Arguments = string.Format("\"{0}\" \"{1}\"", engineCmd, pathToFile);
            processInfo.UseShellExecute = false;// Do not use OS shell
            processInfo.CreateNoWindow = true; // We don't need new window
            processInfo.RedirectStandardOutput = true;// Any output, generated by application will be redirected back
            processInfo.RedirectStandardError = true; // Any error in standard output will be redirected back (for example exceptions)

            using (var process = Process.Start(processInfo))
            {
                using (var reader = process.StandardOutput)
                {
                    string result = reader.ReadToEnd(); // Here is the result of StdOut(for example: print "test")

                    process.WaitForExit();

                    if (result != "True\r\n")
                        throw new Exception("Wolfram engine ended incorrectly!");
                }
            }
        }

        //public string ExecuteCmdViaAPI(string cmd) =>
        //    _ml.EvaluateToOutputForm(cmd, 0);

        //public void CloseLink() =>
        //    _ml.Close(); // Always Close link when done

        public (ulong coeff, List<(GFPoly, int)> irrFactors) Factor(GFPoly f)
        {
            // command to run factor list on wolfram language
            var factorCmd = (string p, ulong m) =>
            $"res = FactorList[FromDigits[Reverse[{p}], x], Modulus -> {m}];" +
            "For[i=1, i <= Length[res], i++," +
            "        t = res[[i]];" +
            "        prt = ToString[" +
            "                        InputForm[" +
            "                                    t[[1]]" +
            "                                 ]" +
            "                      ] <> FromCharacterCode[59] <>" +
            "              ToString[" +
            "                        InputForm[" +
            "                                    t[[2]]" +
            "                                 ]" +
            "                      ];" +
            "        Print[prt]" +
            "   ];";

            //var engine = new WolframEngine();

            var gf = f.Field;

            var factors = ExecuteCmd(factorCmd(f.ToString(),
                                                      gf.Order).Replace(" ", string.Empty))
                .Split("\r\n");

            var irrFactors = new List<(GFPoly, int)>();

            if (f.Deg < 1)
                irrFactors.Add((new(gf, "1"), 1));

            ulong coeff = ulong.Parse(factors[0].Split(';')[0].Replace(" ", string.Empty));

            for (int i = 1; i < factors.Length - 2; ++i)
            {
                var tmp = factors[i].Split(';');

                var pol = tmp[0].Replace(" ", string.Empty);
                var exp = tmp[1].Replace(" ", string.Empty);

                irrFactors.Add((new(f.Field, pol), int.Parse(exp)));
            }

            return (coeff, irrFactors);
        }
    }
}
